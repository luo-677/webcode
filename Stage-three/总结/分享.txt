搜索框输入内容：
    1.浏览器进程启动UI(user interface)线程
    2.捕捉输入的内容
    3.判断：
        3.1 输入的是网址
            启动一个网络线程去请求DNS进行域名解析，连接服务器进行数据获取
        3.2 输入的是关键字
            使用默认配置的搜索引擎进行查询

网络线程获取data --> safebrowsing判断是否恶意站点
        (safebrowsing是谷歌内部的站点安全系统，通过站点数据来判断站点是否安全，比如当前的IP是否在谷歌的黑名单中)
    是 --> 展示警告页面，阻止继续访问，也可以进行强行访问
    否 --> 当数据返回ok时，通知UI线程创建渲染器进程，用于渲染页面

浏览器进程会通过IPC通道将数据传递给渲染器进程，渲染器进程将HTML，CSS，JS，Img(静态资源文件)渲染成web页面
    XRQ进程主线程将html进行解析，构造DOM数据结构
        DOM：文档对象模型，是浏览器对页面在其内部的表现形式，是程序员可以通过JS与之进行交互的数据结构和API
        HTML --> 
            Tokenizer(标记) --> 
                通过词法分析将输入的HTML内容解析成多个标记 --> 
                    通过识别标记进行DOM树构造(tree construction) --> 
                        在DOM树构造的时候会创建document对象 --> 
                            以document为根节点的DOM树不断进行修改，添加各种不同元素
HTML中会引入一些额外的img，css，js资源，img和css可以通过网络下载或者本地缓存进行直接加载，这些资源不会阻塞HTML解析，它们不会影响DOM的生成。
当Tokeniser遇到了script标签时，会停止DOM树构造，转而去解析JS脚本，因为浏览器并不知道JS会不会改变当前的HTML结构，如果JS中使用了如document.write修改了HTML的结构，那么之前的HTML解析就直接白给...
    1.将script标签放在合适的位置
    2.使用async或者defer属性进行异步加载执行js
HTML解析完成后，获得完整的DOM tree
    
主线程需解析CSS并确定每个DOM节点的计算样式，即使没有提供自定义的CSS样式，浏览器也会有默认的样式表，有了DOM结构和每个节点的样式后，接下来就需要知道每个节点放在页面上的哪个位置(节点的左边和需要占用的区域) -- layout布局

主线程通过遍历DOM和计算好的样式来生成layout tree，layout tree上的每个节点都记录了{X,Y}坐标和边框尺寸
注意：
    DOM tree 和 layout tree 并不是一一对应的
        设置了 display:none 的节点不会出现在 layout tree 上
        在before等伪类中添加了content值的元素，content里的内容会出现在layout tree上，不会出现在DOM树里面
    DOM tree 是通过HTML解析获得的，并不关系样式
    layout tree 是根据DOM tree和计算好的样式进行生成的，它和最后展示在屏幕上的节点一一对应

以上任务完成，得到了元素的大小，形状和位置

接下来还需要知道用什么样的顺序进行节点绘制，就比如Z-Index会影响节点绘制的层级关系，如果只按照DOM的层级结构来绘制页面则会导致错误的渲染

主线程遍历layout tree创建一个绘制记录表(Paint Record)进行页面绘制

所有信息准备完毕，开始转化成像素点(栅格化)，页面所有元素按照某种规则进行划分图层，并把图层都栅格化好，只需要把可视区的内容组合成一帧进行展示

主线程遍历 layout tree 生成layer(图层) tree
layer tree 生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程，合成器线程将每个图层进行栅格化，由于一层可能像页面的整个长度一样大，因此合成器线程将他们切分为许多图块(tiles)，然后将每个图块发送给栅格化线程，栅格化线程栅格化每个图块，并将他们存储在CPU内存中，当图块栅格化完成后，合成器线程将收集称为"draw quads"的图块信息，这些信息记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息，根据这些信息，合成器线程生成了一个合成器帧(compositor frame)，然后这个合成器帧通过IPC传递给浏览器进程，浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上，当页面发生滚动时，会新生成一个合成器帧，新帧传递给GPU然后再次渲染到屏幕上。

当我们改变一个元素的尺寸位置属性时，会重新进行样式计算(computed style)布局(layout)绘制(Paint)以及后面的所有流程，这种行为称之为重排。
当我们改变某个元素的颜色属性时，不会重新触发布局，但还是会触发样式计算和绘制，这个是重绘

重排和重绘都运行在主线程上，一旦触发进行占用主线程，不巧的是，JS也运行在主线程上，所以他们俩就会出现抢占主线程运行的情况。
如果写了一个不断导致重排和重绘的动画，浏览器在每一帧都要进行样式计算布局和绘制的操作，当页面在进行帧切换的时候，JS运行时间过长，就会导致画面出现卡顿。
    解决方法：
        1.requestAnimationFrame()
        这个方法在每一帧都会被调用，通过API回调，然后我们可以把JS运行任务分成一些更小的任务快(分到每一帧)在每一帧时间用完前暂停了JS执行，归还主线程
        2.transform
        栅格化的整个流程是不占用主线程的，只在合成器线程和栅格线程中运行，它不会和JS抢夺主线程
        transform实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格化线程，所以不会受到主线程JS的影响
        通过transform实现的动画由于不需要经过布局绘制样式计算等操作，节省了很多运算时间