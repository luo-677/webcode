# mustache语法
1. 大括号中支持js语法操作
2. 大括号中不支持html标签解析
3. 大括号本身就是vue实例的一部分，已经指定了具体的实例，所以使不使用this都可以

# v-if 和 v-show
1. 两者都使用布尔值进行判断
2. v-if 牵涉到节点的创建和销毁，v-show 只是节点状态的隐藏
3. 当一个节点需要频繁进行隐藏和显示时，使用 v-show，否则使用 v-if

# v-bind
## v-bind-class
1. 绑定class，可以在绑定内容中传入 对象 或者 数组
2. 传入对象会有一个问题，不能使用 this.obj.xx = xx 进行对象补充，这种不是响应式的写法，view不会进行更新
3. 传入数组则没有这个问题，数组除了使用索引进行更改数据这种方法，其他的方法都支持响应式
4. Vue.set(this.xxx,index,"xxx") vue自带的数组修改方法
## v-bind-style
1. 绑定style，可以使用三目写法 ， 对象 或者 数组
2. 跟class一样，使用对象写法不能使用指定key的方式进行新增，vue不会进行响应
3. 可以通过指定key进行数据修改，对于已经存在的key，修改数据后vue会进行响应
4. 通过数据的方法去修改style就不会有不响应的问题，在数组中将样式当做一个对象进行传入即可 this.arr.push({background: red})，数组要进行修改，直接往里面传入新对象将前面的内容进行覆盖即可

# v-if , v-else-if , v-else
1. v-if 进行条件判断的时候，不一定要使用第三方状态值，如果有数组，可以使用 arr.length 作为条件判断

# v-for
1. 可以直接遍历 数组 和 对象
2. (item,index) in arr
3. (key[关键字，需要进行验证],value,index[基本也用不上]) in obj
4. v-for 中 in 和 of 的效果是一样的

# v-for中的key
1. v-for="data in arr / obj" key="data.id" key的存在，是为了防止vue在进行渲染时出现不响应的结果，结合diff原理

# 修改数组的方法
1. 只要是数组中的方法不能直接修改数组本身，vue就无法进行响应，如 filter() concat() slice() map()，解决办法，生成的结果直接覆盖原有数组
2. 当需要通过下标进行修改数据时，可以使用 splice 和 Vue.set 两种方法进行修改
   
# 修改对象的方法
1. 通过key值直接修改对象：Vue.set(this.obj, 'key', 'value') 有则修改，无则新增

# 输入框的事件
1. input事件：只要value值发生改变，就会触发input事件
2. change事件：value值发生改变，且文本框失去焦点
3. 案例：在输入框中输入内容时，实时修改页面结果
    1. 使用input事件，将数据过滤方法绑定到input事件上
    2. 使用v-model绑定value值
    3. 使用filter方法进行数据过滤 this.arr.filter(item=>{item.indexOf(this.value)>-1}) 对返回的新数组进行渲染

# 事件绑定
1. @click="xxx(xx)" 添加括号与否，决定于是否需要传入参数
2. 当js的代码十分简短时，可以直接在标签中进行书写

# 事件修饰符
1. .stop 阻止事件冒泡
2. .prevent 阻止默认事件
3. .self 只有事件源是本身的时候才会触发事件，并不是阻止事件冒泡
4. .once 事件触发一次后，立即解绑，比如说抽奖
5. .enter / .13 键盘事件的修饰符 vue中将所有的键值进行了绑定，只要知道需要使用的案件的键值，就能使用每一个按键
6. 键盘多个修饰符同时使用？？？？？

# 表单控件的绑定 v-model
1. 当使用checkbox单选的时候，只要将某一个状态值绑定给v-model就行，通过修改这个状态值来决定是否被选中，值会自动转成布尔值
2. 当使用checkbox多选的时候，需要绑定一个数组，每一个选择标签都需要指定value，当选中时，value会自动添加到数组中
3. 当使用radio进行单选时，绑定一个值，就能继续数据响应 v-model="sex"
4. 当状态发生改变，那么依赖这个状态的函数也会重新进行执行计算
5. 表单全选全不选，新建一个空数组，当全选时将原数组直接赋值给空数组，全不选时直接将新建的数组置空
6. 案例：一个全选按钮控制下面分按钮的状态，下面分按钮的选中状态也会影响到上面的总按钮，计算总价格，有两个按钮用于控制商品数量

# v-model的修饰符
1. .lazy 只有输入框在键入enter或者失去焦点时，才会触发响应修改
2. .number 对输入框进行过滤，只响应数字部分，但是如果一开始输入的就不是数字是字母，那么这个修饰符就直接失效了
3. .trim 将输入内容的左右两边的空格去除

# fetch 和 axios
1. 这两个都不是vue框架中自带的组件
2. fetch的格式非常严格，需要使用res.json()返回一个json格式的promise对象，然后将这个promise对象return出去，然后再使用then等方法进行数据操作
3. axios 会在返回数据的外层包装一个data，所以在获取数据时需要使用 data.res

# 计算属性 computed
1. 计算属性在定义的时候按照函数进行定义，使用的时候按照属性进行使用，他是状态中的数据进行二次处理后返回给外层进行调用
2. 依赖的状态发生改变，计算属性会再次进行计算

# 计算属性和方法函数的异同
1. 两者都是通过函数方式进行声明
2. 计算属性在经过一次计算后，会将结果缓存在内存中，只要依赖的状态值不发生改变，它就不会再进行重新计算
3. 方法函数只要是这个地方需要它，它就会进行运算，不管之前有没有运算过
4. 计算属性可以用来提高性能，如模糊查询

# 计算属性的进阶使用方式
1. 计算属性可以放在 v-for="data in 计算属性" 可用于模糊查询，因为计算属性中需要进行匹配的参数是状态依赖，一旦状态依赖改变时立即触发计算属性，不需要手动进行触发(空字符串在字符串中使用indexOf进行匹配时，永远是0)
2. this.dataList.filter(el => el.indexOf(状态依赖) > -1)
3. 当操作的数据源都来自本地时，使用计算属性会事半功倍

# VUE为什么能优化网页性能，提升用户体验？Mixins
1. VUE使用diff算法，尽可能减少DOM操作，提升节点的复用性，减少节点创建
2. diff算法只进行同层级对比，使用key值进行对比，同组件进行对比，当标签名相同时，只修改内容，不进行标签重复创建

# 组件
1. 在组件的最外层，只能是一个根节点
2. 组件在定义data时，必须使用函数进行定义，将需要的数据return出来

# 组件通信
1. 父传子：(1)在父组件中定义好数据 (2)在子组件中引入props属性，将需要传输的数据进行必要的限制(数据类型校验，设置默认值，是否必传) (3)在父组件中的子组件标签上进行数据绑定，要是用响应式绑定，不然传递的就是一个字符串 (4)在子组件中使用传递的数据
2. 子传父：(1)在子组件的内容中写好触发事件 (2)在子组件的methods中自定义事件，并且使用$emit进行传递 (3)在父组件中的子组件标签上绑定自定义事件 (4)在父组件的methods中定义方法来接收并处理接收到的数据

# $refs
1. 使用$refs可以获取到当前父组件下面的所有子组件，并且以对象形式进行返回
2. $refs对子组件有绝对的访问权，子组件中的所有内容都可以轻易获得，父给子传递数据也只需要将参数放在子方法中传递即可

# $parent
1. 使用$parent可以访问当前节点的父节点

# 非父子组件通信-事件总线
1. 声明一个空Vue实例(bus)，作为事件总线
2. 在发送方中定义 bus.$emit 将数据传递给事件总线
3. 子组件为了能尽早订阅到发送方的数据，所以要在DOM节点生成的同时进行数据接收，将方法写到mounted中，使用bus.$on接收数据

# 动态组件
1. 使用<component>元素，使用is属性将多个组件进行绑定，is绑定的是子组件的名称
2. <keep-alive>保留标签内内容的状态，不会进行重新渲染

# 插槽
1. 插槽的作用，在子组件中放入插槽，在父组件中可在子组件的范围内书写内容，且这些内容可以直接访问父组件中的数据
2. 具名插槽：在插槽中指定一个name属性，将需要固定的name写在name属性中，在真正插入插槽中的标签上使用slot属性，写上对应的name

# transition
1. Vue提供了一种动画辅助方式，样式得自己写，但是Vue会帮你添加类名和删除类名
2. C3动画需要自己写，类名中 name-enter-active name-leave-active name-enter name-leave-to 中 name 自定义
3. transition标签中，指定name属性来绑定动画中得name，当节点出现或者消失时，自动添加或者移除类
4. transition和transition-group都提供了两种切换方式：mode="in-out / ou-in"
5. 多标签和多组件过度原理是一样的，都是通过 transition 进行过度，需要注意的是，如果标签名相同，需要使用key来进行区分，以保证不受diff算法的影响，多组件如果需要保留原始操作痕迹，需要使用keep-alive组件进行包裹
6. 列表过渡，内部包含多个元素，所以使用transition-group进行切换，列表过渡一定要使用key值进行区分

# 生命周期
1. 当状态属性发生改变时，就会触发更新阶段，更新阶段可以一直被触发

# 使用swiper的问题
1. vue中状态属性发生变动之后，会异步更新dom节点，需要花费一定的时间，所以在状态修改完成后去获取dom节点，不一定能获取到
2. swiper初始化过早，其实节点并没有生成，所以swiper初始化要放在updated生命周期中进行(前提是状态属性的变化不大)
3. 所以swiper初始化还是得放在mounted生命周期中，为了解决状态属性发生更改后swiper不再进行更新的问题，需要在swiper根节点上加上key值，以解决diff算法的问题

# 自定义指令
1. 当需求实在要进行DOM操作时，可以使用自定义指令进行DOM操作的编写，自定义指令也有类似于自己的生命周期
2. inserted(el,bind) -- 这是创建阶段，只能使用一次
3. el为被创建出来的DOM对象，说明此时标签已经被实例化了
4. bind为整个指令对象，可以从bind中获取到外界传入的参数，指令只接收一个参数，但可以是对象
5. update(el,bind) -- 这是更新阶段，只要状态数据发生了改变，就会触发当前阶段
6. 指令中是无法通过this指向去拿到组件中的数据的，但是可以像 v-for="data in list" 一样，直接取到 list 值
7. 案例：初始化swiper时，容易造成节点还没有产生就去初始化swiper，导致生成失败，可以通过自定义指令，将当前节点的下标值等于 当前节点总数的长度-1 时，再进行swiper的初始化
8. 指令的复用性比较差，一般都是在需要操作底层DOM来实现某种功能时才进行使用

# 过滤器
1. 使用 (data | way) 的方式将data通过way这种方式进行转化
2. 本质上和定义一个函数进行返回是一模一样的，只是写法上更加高级

# vue脚手架
1. lint to fixed 自动修复格式错误
2. in dedicated config files 生成单独的配置文件，方便进行修改
3. node-sass 包在安装的时候容易出错，一旦出错，就将nodemodules文件夹进行删除，使用cnpm i再下载一遍

# 组件开发
1. 在Vue组件开发中,每一个组件都是一个单独的vue文件
2. template中只能有一个根节点标签,template不能算,它本身并不参与最终的文件组成
3. 使用es6模块化进行组件引入,引入完成后需要对组件进行注册(全局注册和局部注册)
4. 组件开发最容易碰到的问题就是样式冲突，需要在每个组件文件中的style标签部分添加一个scoped，这样的话每个组件都有自己的样式文件
5. scoped原理，给每一个模块根节点添加一个唯一的属性，通过这个属性去绑定样式表

# 代码上线
1. yarn lint 使用安装好的es6格式化工具将所有的代码格式化成标准的es6格式
2. yarn build 将所有的vue代码进行打包，生成一个dist文件夹，该文件夹下都是浏览器可运行的文件

# 反向代理
1. 在与package.json文件同级目录下，创建vue.config.js文件
2. 在文件中使用devServer模块，固定格式，第一个参数为目标接口的开头
3. 重中之重！！！！！！！！修改了配置文件一定要重启项目！！！！！！！！！！！

# 项目中文件存放的位置
1. components 用于存放通用组件的文件夹
2. views 用于存放页面级的组件
   
# 路由
1. 路由的写法比较固定，都是将一个路径别名对应一个页面组件，在Vue的根组件中需要将root参数写入
   1. 在根组件的页面中引入容器 <router-view></router-view>
   2. 引入多个容器也只是重复进行显示，并不会展示不同的东西
   3. 能不能在不是根节点的页面中展示？？？ 子路由可以在父路由的页面中显示，但是路由参数需要配置在根节点中
2. 路由声明式导航：<router-link to="跳转的路径" tag="需要变成的标签名" activeClass="响应式类"></router-link>
   1. activeClass 会在路由被激活时自动获取对应的样式类，这个参数名是固定的，不可以随意更改
3. 声明式导航，编程式导航(使用原生js进行导航跳转)
4. 路由的重定向：{path: "*", redirect: "/xxx"}
5. 子路由 父路由{ children:[{子路由1}, {子路由2}]}
   1. 为了使得代码的阅读性更强，在写子路由页面时，重新建立一个文件夹，这个文件夹的名字与父路由的名字相同
   2. 子路由的路径可以是相对路劲也可以是绝对路径，但是要注意，在写相对路径时，前面不可以加上斜杠，一旦有斜杠就变成了绝对路径
   3. 如果在父路由中嵌入了子路由，那么子路由也需要加上重定向：{path: "", redirect: "/xxx"}，且为空，如果不加入重定向，在地址栏中手动输入父路由地址则不会加载子路由页面
6. 动态路由：this.$router === router实例 使用编程式导航进行路由跳转
   1. 路径跳转
      1. this.$router.push(`/xxx/${id}`)
      2. path: '/xxx/:id'
      3. 获取传过去的id值 在mounted生命周期中 this.$route.params.id
   2. 名称跳转
      1. 在路由配置中增加一个name属性
      2. this.$router.push({name: "前面的命名", params: {id: id}}) 参数的名称要与路径配置中的占位符的名称保持一致

# 别名的配置？